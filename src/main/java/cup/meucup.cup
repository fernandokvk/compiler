package cup;
import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import misc.TokenInfo;
import ast.*;

parser code {:
//Coment√°rios abaixo obtidos do manual (https://www.cs.princeton.edu/~appel/modern/java/CUP/manual.html)
/*
This method should be called whenever an error message is to be issued.
In the default implementation of this method, the first parameter provides the text of a
message which is printed on System.err and the second parameter is simply ignored.
It is very typical to override this method in order to provide a more sophisticated error reporting mechanism.
*/

    public void report_error(String message, Object info) {
            if (info instanceof Symbol) {
                Symbol symbol = (Symbol) info;
                TokenInfo tokenInfo = symbol.value instanceof TokenInfo ? (TokenInfo) symbol.value : null;

                if (tokenInfo != null) {
                    int linha = tokenInfo.linha;
                    int coluna = tokenInfo.coluna;
                    String lexema = tokenInfo.lexema;
                    System.err.println("Erro sintatico - linha: " + (linha + 1) + ", coluna " + (coluna + 1) + ", lexema: '"+ lexema +"' - " + message);
                } else {
                    System.err.println("Erro sintatico: " + message);
                }
            } else {
                System.err.println("Erro sintatico: " + message);
            }
        }
/*
This method should be called whenever a non-recoverable error occurs.
It responds by calling report_error(), then aborts parsing by calling the parser method done_parsing(),
and finally throws an exception. (In general done_parsing() should be called at any point that parsing needs to be terminated early).
*/
    public void report_fatal_error(String message, Object info) {
        report_error("Erro fatal: " + message, info);
        System.exit(1);
    }
/*
This method is called by the parser if it is unable to recover from a syntax error.
In the default implementation it calls: report_fatal_error("Couldn't repair and continue parse", null);.
*/
    public void unrecovered_syntax_error(Symbol cur_token) {
        report_fatal_error("O analisador lexico falhou e nao se recuperou", cur_token);
    }
/*
This method is called by the parser as soon as a syntax error is detected (but before error recovery is attempted).
In the default implementation it calls: report_error("Syntax error", null);.
*/
        public void syntax_error(Symbol cur_token){
            report_error("Erro sintatico", cur_token);
        }
:};


terminal TokenInfo BEGIN, END, PROGRAMA;
terminal TokenInfo FUNCTION, RETURN, PROCEDURE, PROC;
terminal TokenInfo VIRGULA, DOIS_PONTOS, PT_VIRGULA;
terminal TokenInfo L_PARENTESES, R_PARENTESES, L_CHAVES, R_CHAVES;
terminal TokenInfo MENOR, MAIOR, IGUAL_IGUAL, DIFERENTE, MENOR_IGUAL, MAIOR_IGUAL;
terminal TokenInfo IGUAL, ADD_IGUAL, SUB_IGUAL;
terminal TokenInfo AND, OR;
terminal TokenInfo ADD, SUB, MUL, DIV;
terminal TokenInfo TIPO_CHAR, TIPO_INTEIRO, TIPO_FLUTUANTE, TIPO_BOOLEAN;
terminal TokenInfo IF, ELSE, WHILE, FOR, DO;
terminal TokenInfo INTEIRO, FLUTUANTE, ID, CARACTERE;
terminal TokenInfo BOOL_TRUE, BOOL_FALSE;

nonterminal InitProgramaNode init_programa;
nonterminal ProgramaNode programa;
nonterminal BlocoNode bloco;
nonterminal InstrucoesNode instrucoes;
nonterminal InstrucaoNode instrucao;
nonterminal CondicoesNode condicoes;
nonterminal ExpressoesNode expressoes;
nonterminal ExpressaoNode expressao;
nonterminal ArgumentosNode argumentos;
nonterminal ParametrosNode parametros;
nonterminal ParametroNode parametro;
nonterminal InicializacaoNode inicializacao;
nonterminal AtribuicaoNode atribuicao;
nonterminal DeclaracaoNode declaracao;
nonterminal TipoNode tipo;
nonterminal VarNode var;
nonterminal VarForNode var_for;
nonterminal LiteralNode literal;
nonterminal OperadorNode operador;
nonterminal OperadorLogicoNode operador_logico;
nonterminal OperadorAritmeticoNode operador_aritmetico;
nonterminal OperadorComparacaoNode operador_comparacao;
nonterminal OperadorAtribuicaoNode operador_atribuicao;


precedence left IGUAL, ADD_IGUAL, SUB_IGUAL;
precedence left OR;
precedence left AND;
precedence left IGUAL_IGUAL, DIFERENTE, MENOR, MAIOR, MENOR_IGUAL, MAIOR_IGUAL;
precedence left ADD, SUB;
precedence left MUL, DIV;

start with programa;


init_programa ::= PROGRAMA L_PARENTESES ID:id R_PARENTESES DOIS_PONTOS {: RESULT = new InitProgramaNode(id);:};

programa ::= init_programa:ini BEGIN bloco:bloco END {: RESULT = new ProgramaNode(ini, bloco);:};

bloco ::= L_CHAVES instrucoes:instrs R_CHAVES
        {:
            RESULT = new BlocoNode((InstrucoesNode)instrs);
        :};


instrucoes ::= instrucao:instr
            {:
                InstrucoesNode instructions = new InstrucoesNode();
                instructions.addInstrucao((InstrucaoNode)instr);
                RESULT = instructions;
            :}
            | instrucao:instr instrucoes:instrs
            {:
                InstrucoesNode instructions = new InstrucoesNode();
                instructions.addInstrucao((InstrucaoNode)instr);
                instructions.addAllInstrucoes(((InstrucoesNode)instrs).instrucoes);
                RESULT = instructions;
            :};

instrucao ::= FOR L_PARENTESES var_for VIRGULA condicoes VIRGULA atribuicao R_PARENTESES bloco
           |  WHILE L_PARENTESES condicoes R_PARENTESES bloco
           |  DO bloco WHILE L_PARENTESES condicoes R_PARENTESES PT_VIRGULA
           |  IF L_PARENTESES condicoes R_PARENTESES bloco
           |  IF L_PARENTESES condicoes R_PARENTESES bloco ELSE bloco
           |  FUNCTION ID L_PARENTESES parametros R_PARENTESES DOIS_PONTOS tipo L_CHAVES instrucoes RETURN var PT_VIRGULA R_CHAVES
           |  PROCEDURE ID L_PARENTESES parametros R_PARENTESES bloco
           |  PROC ID L_PARENTESES argumentos R_PARENTESES PT_VIRGULA
           |  inicializacao:x PT_VIRGULA {: :}
           |  atribuicao PT_VIRGULA
           |  declaracao:decl PT_VIRGULA {:RESULT = decl;:}
           ;

condicoes ::= expressao | expressao operador_logico condicoes | expressao operador_comparacao condicoes;

parametros ::= parametro | parametro VIRGULA parametros | /* vazio */;

parametro ::= tipo ID;

argumentos ::= expressao | expressao VIRGULA argumentos | /* vazio */;

expressoes ::= expressao | expressao operador expressoes;

expressao ::= var
           |  ID L_PARENTESES argumentos R_PARENTESES
           |  var operador_aritmetico var;

var ::= ID:id {: RESULT = new VarNode(id);:} | literal:lit {: RESULT = new VarNode(lit); :};

literal ::= INTEIRO:x {: RESULT = new LiteralNode(x); :}
         | FLUTUANTE:x {: RESULT = new LiteralNode(x); :}
         | CARACTERE:x {: RESULT = new LiteralNode(x); :}
         | BOOL_TRUE:x {: RESULT = new LiteralNode(x); :}
         | BOOL_FALSE:x {: RESULT = new LiteralNode(x); :};


var_for ::= inicializacao
         |  atribuicao
         |  ID;

inicializacao ::= tipo ID IGUAL expressoes;
atribuicao ::= ID:id operador_atribuicao:op expressoes:expr {: RESULT = new AtribuicaoNode(id, op, expr); :};
declaracao ::= tipo:tipo ID:id {: RESULT = new DeclaracaoNode(tipo, id);:};

operador ::= operador_logico
          | operador_aritmetico
          | operador_comparacao;

operador_logico ::= AND | OR;
operador_comparacao ::= MENOR
                     | MAIOR
                     | IGUAL_IGUAL
                     | DIFERENTE
                     | MENOR_IGUAL
                     | MAIOR_IGUAL;
operador_aritmetico ::= ADD
                     | SUB
                     | MUL
                     | DIV;
operador_atribuicao ::= IGUAL
                  | ADD_IGUAL
                  | SUB_IGUAL;

tipo ::= TIPO_CHAR:x {: :}
    | TIPO_FLUTUANTE:x{: :}
    | TIPO_INTEIRO:x{: :}
    | TIPO_BOOLEAN:x{: :};
